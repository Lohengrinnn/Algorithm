Generally speaking, there are 3 types of binary search pattern, which differ from each other with: 1. termination condition, 2. l-r cursor move method.
1)
   while l < r:          l < r: means if l meets r, terminate.
       if xxxx:
           l = m + 1
       else:
           r = m - 1
2) 
   while l <= r:         l <= r: means if l meets r, need to do one more search
       if xxxx:
           l = m + 1
       else:
           r = m - 1
3)
   while l <= r:
       if xxxx:
           l = m + 1
       else:
           r = m         r = m, instead of "m - 1", means only when l moves, it skips m, but r stops at m

pattern 1: quick sort
pattern 2: binary search in sorted array
pattern 3: binary search in rotated sorted array

For the pattern 1, the m is a pivot, used to divide with l and r. if l == r, means this half has only one element, for the sake of sort, no need to process, but if the purposes is search, still need to process it.
For the pattern 2, as decribed above, when l == r, still need to process the last one element.
For the pattern 3, the difference with pattern 2 is the pattern 3's hit point can't be decided on each single loop independently.
for example: find smallest element in a rotated sorted array, the hit point should be the leftest number not bigger than nums[0]
methods:
1. if nums[m] > nums[l]: l = m + 1
2. else:                 r = m
5, 6, 7, 1, 2, 3, 4 // l = 0, r = 6, m = 3
5, 6, 7, 1          // l = 0, r = 3(m), if it used m - 1, r = 2, l will never encounter 1[3]
                    // another explanation is, the condition nums[m] < nums[l] can't determine if it's the leftest, so it may be the correct hit point.
